---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/scraper/client.ts
  - src/scraper/rate-limiter.ts
  - src/cache/database.ts
  - src/cache/repository.ts
  - src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "HTTP requests include realistic browser headers"
    - "Failed requests retry with exponential backoff"
    - "Requests are delayed by configurable amount (default 1500ms)"
    - "Cached responses are returned without network request"
    - "Expired cache entries are cleaned on startup"
    - "Progress bar shows X/Y items processed during fetch loop"
  artifacts:
    - path: "src/scraper/client.ts"
      provides: "HTTP client with retry logic"
      exports: ["fetchWithRetry", "GitHubClient"]
    - path: "src/cache/database.ts"
      provides: "SQLite database connection"
      exports: ["createDatabase", "closeDatabase"]
    - path: "src/cache/repository.ts"
      provides: "Cache read/write operations"
      exports: ["CacheRepository"]
  key_links:
    - from: "src/scraper/client.ts"
      to: "src/cache/repository.ts"
      via: "checks cache before fetching"
      pattern: "cache\\.get|cacheRepository"
    - from: "src/scraper/client.ts"
      to: "src/scraper/rate-limiter.ts"
      via: "applies delay between requests"
      pattern: "delay|sleep|rateLimiter"
    - from: "src/cache/repository.ts"
      to: "src/cache/database.ts"
      via: "uses database connection"
      pattern: "database|db"
    - from: "src/cli/index.ts"
      to: "src/output/progress.ts"
      via: "displays progress during fetch"
      pattern: "createProgressBar|progress"
---

<objective>
Create the HTTP client with retry logic, rate limiting, and SQLite caching infrastructure.

Purpose: Enable reliable scraping of GitHub without getting blocked - delays prevent rate limiting, retries handle transient failures, caching avoids redundant requests.

Output: A `GitHubClient` class that fetches URLs with automatic caching, delays, and exponential backoff on failures.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLite cache layer</name>
  <files>src/cache/database.ts, src/cache/repository.ts, src/types/index.ts</files>
  <action>
Create the caching infrastructure using better-sqlite3 and env-paths:

1. Update src/types/index.ts - add cache-related types:
   ```typescript
   export interface CacheEntry {
     key: string;
     value: string;
     expiresAt: number;  // Unix timestamp ms
   }

   export interface CacheConfig {
     dbPath?: string;     // Override default path
     ttlMs?: number;      // Override default TTL (7 days)
   }
   ```

2. Create src/cache/database.ts:
   ```typescript
   import Database from 'better-sqlite3';
   import envPaths from 'env-paths';
   import { mkdirSync, existsSync } from 'fs';
   import { dirname } from 'path';

   const paths = envPaths('gitsneak');
   const DEFAULT_DB_PATH = `${paths.cache}/cache.db`;

   export function createDatabase(dbPath: string = DEFAULT_DB_PATH): Database.Database {
     // Ensure cache directory exists
     const dir = dirname(dbPath);
     if (!existsSync(dir)) {
       mkdirSync(dir, { recursive: true });
     }

     const db = new Database(dbPath);

     // Create cache table if not exists
     db.exec(`
       CREATE TABLE IF NOT EXISTS cache (
         key TEXT PRIMARY KEY,
         value TEXT NOT NULL,
         expires_at INTEGER NOT NULL
       )
     `);

     // Create index for expiration queries
     db.exec(`
       CREATE INDEX IF NOT EXISTS idx_cache_expires ON cache(expires_at)
     `);

     return db;
   }

   export function closeDatabase(db: Database.Database): void {
     db.close();
   }

   export function getDefaultDbPath(): string {
     return DEFAULT_DB_PATH;
   }
   ```

3. Create src/cache/repository.ts:
   ```typescript
   import type Database from 'better-sqlite3';
   import type { CacheStats } from '../types/index.js';

   const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;

   export class CacheRepository {
     private db: Database.Database;
     private getStmt: Database.Statement;
     private setStmt: Database.Statement;
     private deleteExpiredStmt: Database.Statement;
     private ttlMs: number;

     // Track stats for this session
     private stats: CacheStats = { hits: 0, misses: 0 };

     constructor(db: Database.Database, ttlMs: number = SEVEN_DAYS_MS) {
       this.db = db;
       this.ttlMs = ttlMs;

       // Prepare statements for performance
       this.getStmt = db.prepare('SELECT value FROM cache WHERE key = ? AND expires_at > ?');
       this.setStmt = db.prepare('INSERT OR REPLACE INTO cache (key, value, expires_at) VALUES (?, ?, ?)');
       this.deleteExpiredStmt = db.prepare('DELETE FROM cache WHERE expires_at <= ?');

       // Clean up expired entries on initialization
       this.cleanExpired();
     }

     get(key: string): string | null {
       const now = Date.now();
       const row = this.getStmt.get(key, now) as { value: string } | undefined;

       if (row) {
         this.stats.hits++;
         return row.value;
       }

       this.stats.misses++;
       return null;
     }

     set(key: string, value: string): void {
       const expiresAt = Date.now() + this.ttlMs;
       this.setStmt.run(key, value, expiresAt);
     }

     cleanExpired(): number {
       const now = Date.now();
       const result = this.deleteExpiredStmt.run(now);
       return result.changes;
     }

     getStats(): CacheStats {
       return { ...this.stats };
     }

     resetStats(): void {
       this.stats = { hits: 0, misses: 0 };
     }
   }
   ```
  </action>
  <verify>
`npm run build` succeeds
Create a test script that:
- Creates database
- Sets a value
- Gets the value back
- Verifies stats show 1 miss (first get before set would miss), then 1 hit
Run with: `node -e "...test code..."`
  </verify>
  <done>
SQLite cache stores key-value pairs with TTL expiration, tracks hit/miss stats, cleans expired entries on startup
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP client with retry and rate limiting</name>
  <files>src/scraper/rate-limiter.ts, src/scraper/client.ts</files>
  <action>
Create the HTTP fetching infrastructure with delays and retries:

1. Create src/scraper/rate-limiter.ts:
   ```typescript
   /**
    * Sleep for specified milliseconds with optional jitter
    */
   export function sleep(ms: number, jitter: number = 0): Promise<void> {
     const actualDelay = jitter > 0
       ? ms + Math.floor(Math.random() * jitter * 2) - jitter
       : ms;
     return new Promise(resolve => setTimeout(resolve, Math.max(0, actualDelay)));
   }

   /**
    * Rate limiter that enforces minimum delay between calls
    */
   export class RateLimiter {
     private lastRequestTime: number = 0;
     private delayMs: number;
     private jitterMs: number;

     constructor(delayMs: number = 1500, jitterMs: number = 200) {
       this.delayMs = delayMs;
       this.jitterMs = jitterMs;
     }

     async waitForNext(): Promise<void> {
       const now = Date.now();
       const elapsed = now - this.lastRequestTime;
       const remaining = this.delayMs - elapsed;

       if (remaining > 0) {
         await sleep(remaining, this.jitterMs);
       }

       this.lastRequestTime = Date.now();
     }

     setDelay(delayMs: number): void {
       this.delayMs = delayMs;
     }
   }
   ```

2. Create src/scraper/client.ts:
   ```typescript
   import pRetry, { AbortError } from 'p-retry';
   import { RateLimiter } from './rate-limiter.js';
   import { CacheRepository } from '../cache/repository.js';
   import type { FetchResult, GitSneakOptions } from '../types/index.js';

   // Realistic browser headers to avoid detection
   const DEFAULT_HEADERS = {
     'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
     'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
     'Accept-Language': 'en-US,en;q=0.9',
     'Accept-Encoding': 'gzip, deflate, br',
     'Cache-Control': 'no-cache',
     'Pragma': 'no-cache',
   };

   export interface ClientConfig {
     cache: CacheRepository | null;  // null if --no-cache
     delayMs: number;
     maxRetries: number;
     verbose: boolean;
     onRetry?: (attempt: number, error: Error) => void;
   }

   export class GitHubClient {
     private rateLimiter: RateLimiter;
     private cache: CacheRepository | null;
     private maxRetries: number;
     private verbose: boolean;
     private onRetry?: (attempt: number, error: Error) => void;

     constructor(config: ClientConfig) {
       this.rateLimiter = new RateLimiter(config.delayMs);
       this.cache = config.cache;
       this.maxRetries = config.maxRetries;
       this.verbose = config.verbose;
       this.onRetry = config.onRetry;
     }

     /**
      * Fetch a URL with caching, rate limiting, and retry logic
      */
     async fetch(url: string, cacheKey?: string): Promise<FetchResult> {
       const key = cacheKey ?? `url:${url}`;

       // Check cache first (if enabled)
       if (this.cache) {
         const cached = this.cache.get(key);
         if (cached !== null) {
           return { html: cached, fromCache: true };
         }
       }

       // Rate limit before making request
       await this.rateLimiter.waitForNext();

       // Fetch with retry logic
       const html = await this.fetchWithRetry(url);

       // Store in cache (if enabled)
       if (this.cache) {
         this.cache.set(key, html);
       }

       return { html, fromCache: false };
     }

     private async fetchWithRetry(url: string): Promise<string> {
       const run = async () => {
         const response = await fetch(url, {
           headers: DEFAULT_HEADERS,
         });

         // Retriable errors - rate limiting or server issues
         if (response.status === 429 || response.status === 503) {
           throw new Error(`Rate limited (${response.status}): ${url}`);
         }

         // Non-retriable errors - client errors
         if (response.status === 404) {
           throw new AbortError(`Not found (404): ${url}`);
         }

         if (response.status === 403) {
           throw new AbortError(`Forbidden (403): ${url} - may be blocked or private`);
         }

         if (!response.ok) {
           throw new AbortError(`HTTP ${response.status}: ${url}`);
         }

         return response.text();
       };

       return pRetry(run, {
         retries: this.maxRetries,
         factor: 2,           // Double delay each retry
         minTimeout: 2000,    // Start at 2 seconds
         maxTimeout: 60000,   // Max 60 seconds
         randomize: true,     // Add jitter
         onFailedAttempt: (error) => {
           if (this.onRetry) {
             this.onRetry(error.attemptNumber, error);
           }
         },
       });
     }
   }

   /**
    * Factory function to create a configured client from CLI options
    */
   export function createClient(
     options: GitSneakOptions,
     cache: CacheRepository | null,
     onRetry?: (attempt: number, error: Error) => void
   ): GitHubClient {
     return new GitHubClient({
       cache: options.cache ? cache : null,
       delayMs: options.delay,
       maxRetries: 5,
       verbose: options.verbose,
       onRetry,
     });
   }
   ```
  </action>
  <verify>
`npm run build` succeeds
Verify the client module exports are available:
`node -e "import('./dist/scraper/client.js').then(m => console.log(Object.keys(m)))"`
Should show: ['GitHubClient', 'createClient']
  </verify>
  <done>
HTTP client fetches URLs with realistic headers, respects rate limits with configurable delay + jitter, retries with exponential backoff on 429/503, stores results in cache
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire cache, client, and progress bars into CLI</name>
  <files>src/cli/index.ts</files>
  <action>
Update the CLI to initialize cache, create client, and integrate progress bars (per CLI-02):

1. Update src/cli/index.ts imports:
   ```typescript
   import { createDatabase, closeDatabase, getDefaultDbPath } from '../cache/database.js';
   import { CacheRepository } from '../cache/repository.js';
   import { createClient } from '../scraper/client.js';
   import { createProgressBar } from '../output/progress.js';
   ```

2. Update the action handler after URL validation:
   ```typescript
   // Initialize cache (unless --no-cache)
   let cache: CacheRepository | null = null;
   let db: Database.Database | null = null;

   if (options.cache) {
     try {
       db = createDatabase();
       cache = new CacheRepository(db);
       logVerbose(`Cache initialized at ${getDefaultDbPath()}`, options);
     } catch (err) {
       logWarning(`Failed to initialize cache: ${err}. Continuing without cache.`);
     }
   } else {
     logVerbose('Cache disabled (--no-cache)', options);
   }

   // Create HTTP client
   const client = createClient(options, cache, (attempt, error) => {
     logWarning(`Retry ${attempt}/5: ${error.message}`);
   });

   // Create progress bar for fetch loop (respects quiet mode)
   // createProgressBar returns a no-op bar when quiet=true
   const progressBar = createProgressBar(repos.length, 'Repositories', options.quiet);

   // Fetch each repo with progress indication
   for (const repo of repos) {
     try {
       const result = await client.fetch(repo.url);
       logVerbose(`  ${repo.owner}/${repo.repo}: ${result.fromCache ? '(cached)' : '(fetched)'} ${result.html.length} bytes`, options);
       progressBar.increment({ status: result.fromCache ? 'cached' : 'fetched' });
     } catch (err) {
       progressBar.increment({ status: 'error' });
       logError(`Failed to fetch ${repo.url}: ${err}`);
       if (options.failFast) {
         progressBar.stop();
         process.exitCode = 1;
         break;
       }
     }
   }

   // Stop progress bar when done
   progressBar.stop();

   // Show cache stats
   if (cache) {
     const stats = cache.getStats();
     logInfo(`Cache: ${stats.hits} cached, ${stats.misses} fetched`, options);
   }

   // Cleanup
   if (db) {
     closeDatabase(db);
   }

   logSuccess('Foundation infrastructure verified. Data extraction will be implemented in Phase 2.');
   ```

3. Update the progress.ts createProgressBar signature to accept quiet flag:
   If progress.ts from Plan 01-01 does not already handle quiet mode, update it to:
   ```typescript
   export function createProgressBar(total: number, label: string, quiet: boolean = false): SingleBar {
     if (quiet) {
       // Return no-op progress bar for quiet mode
       return {
         increment: () => {},
         stop: () => {},
         update: () => {},
       } as unknown as SingleBar;
     }
     // ... normal progress bar creation
   }
   ```

4. Add graceful shutdown before program.parse():
   ```typescript
   let db: Database.Database | null = null;  // Move to module scope

   process.on('SIGINT', () => {
     if (db) closeDatabase(db);
     process.exit(130);
   });
   ```
  </action>
  <verify>
`npm run build` succeeds

Test progress bar appears (non-quiet mode):
`node dist/cli/index.js https://github.com/sindresorhus/p-retry`
- Should show progress bar: "Repositories [====] 100% | 1/1 | fetched"
- Should complete and show cache stats

Test quiet mode suppresses progress:
`node dist/cli/index.js -q https://github.com/sindresorhus/p-retry`
- Should NOT show progress bar
- Should only show final success message

Test multiple repos show progress:
`node dist/cli/index.js https://github.com/sindresorhus/p-retry https://github.com/tj/commander.js`
- Progress bar should show "0/2" then "1/2" then "2/2"
- Each increment visible during fetch loop

Run again to verify cache + progress interaction:
`node dist/cli/index.js https://github.com/sindresorhus/p-retry`
- Progress bar shows status "cached" instead of "fetched"
- Cache stats show hits

Test --no-cache:
`node dist/cli/index.js --no-cache https://github.com/sindresorhus/p-retry`
- Should show "Cache disabled" in verbose
- Progress bar shows "fetched"
  </verify>
  <done>
CLI initializes cache on startup, creates HTTP client, displays progress bar showing X/Y items processed during fetch loop (respects -q quiet mode), shows cache stats at end, handles errors gracefully
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Cache layer works:
   - Database created at XDG cache path
   - Entries stored with 7-day TTL
   - Expired entries cleaned on startup
   - Stats track hits and misses

2. HTTP client works:
   - Requests include realistic browser headers
   - Delay between requests (1500ms default)
   - Retries on 429/503 with exponential backoff
   - Stops retrying on 404/403 (AbortError)

3. Progress bar integration works:
   - Progress bar displays during fetch loop
   - Shows X/Y format (e.g., "1/3 repositories")
   - Increments after each fetch completes
   - Shows status (fetched/cached/error)
   - Quiet mode (-q) suppresses progress bar
   - Bar stops cleanly on completion or error

4. Integration works:
   - First run fetches from GitHub with progress indication
   - Second run uses cache (progress shows "cached")
   - --no-cache bypasses cache
   - Multiple repos process sequentially with delay and progress
   - Cache stats displayed at end

5. Error handling:
   - Invalid URLs rejected before any network requests
   - Network errors shown in red
   - --fail-fast stops on first error (progress bar stops)
   - Default behavior continues and summarizes
</verification>

<success_criteria>
- Progress bar shows X/Y items processed during fetch operations
- Quiet mode (-q) suppresses progress bar output
- Repeated runs for same repo hit cache (stats show hits)
- Tool respects rate limits with configurable delay
- Auto retry with exponential backoff on transient failures
- Cache location follows XDG standard (env-paths)
- Expired cache entries cleaned on startup (7-day TTL)
- User sees cache stats at end of run
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` using the summary template.
</output>
